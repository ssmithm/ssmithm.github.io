library(truncnorm)
library(pwr)
library(tidyverse)

set.seed(NULL)

# simple correlation
pwr.r.test(r=-0.34, n=100, sig.level=0.05, alternative="two.sided")


# multiple linear regression
u = 3
r2 = .15
f2 = r2 / (1 - r2)


mlr <- function(u, r2) {
  f2 <- r2 / (1 - r2)
  n = ceiling(pwr.f2.test(u = u, # df in numerator, i.e., number of variables other than intercept
              v = NULL, # df in denomenator, i.e., number of error degrees of freedom
              f2 = f2,  # effect size
              sig.level = 0.05,
              power = 0.8)$v + u + 1)
  return(n)
}

mlr2 <- function(u, r2) {
  f2 <- r2 / (1 - r2)
  n = ceiling(pwr.f2.test(u = u, # df in numerator, i.e., number of variables other than intercept
                          v = NULL, # df in denomenator, i.e., number of error degrees of freedom
                          f2 = f2,  # effect size
                          sig.level = 0.05,
                          power = 0.8)$v + 2)
  return(n)
}

save_mlr <- data.frame(u = 3, r2 = seq(.01, .25, by = .01))
save_mlr <- save_mlr |> 
  mutate(ef = r2/(1-r2))
check <- list()
for (i in 1:25) {
  r2 = i/100
  check[[i]] <- mlr(3, r2)
}
check <- unlist(check)
save_mlr[, 4] <- unlist(check)
colnames(save_mlr) <- c("n.covs", "model.r.squared", "scaled.effect.size", "n")
sample.size.ests <- save_mlr

save_mlr <- data.frame(u = 2, r2 = seq(.01, .25, by = .01))
save_mlr <- save_mlr |> 
  mutate(ef = r2/(1-r2))
check <- list()
for (i in 1:25) {
  r2 = i/100
  check[[i]] <- mlr(2, r2)
}
check <- unlist(check)
save_mlr[, 4] <- unlist(check)
colnames(save_mlr) <- c("n.covs", "model.r.squared", "scaled.effect.size", "n")
sample.size.ests <- bind_rows(sample.size.ests, save_mlr)

save_mlr <- data.frame(u = 1, r2 = seq(.01, .25, by = .01))
save_mlr <- save_mlr |> 
  mutate(ef = r2/(1-r2))
check <- list()
for (i in 1:25) {
  r2 = i/100
  check[[i]] <- mlr2(1, r2)
}
check <- unlist(check)
save_mlr[, 4] <- unlist(check)
colnames(save_mlr) <- c("n.covs", "model.r.squared", "scaled.effect.size", "n")
sample.size.ests <- bind_rows(sample.size.ests, save_mlr)

ss.plot.data <- sample.size.ests |> filter(n < 600) |> mutate(n.covs = as.factor(n.covs))

ggplot(data = ss.plot.data, aes(x = model.r.squared, y = n, group = n.covs, colour = n.covs)) +
  geom_point(stat="identity") + 
  geom_line(stat="identity") 




## more complex simulations

fx <- function(n, beta0, beta_pre_dcva, beta_tilt, beta_decent, sigma) {
  pre_dcva <- rtruncnorm(n, a=20, b=1000, mean=140, sd=100)
  pre_dcva <- round(pre_dcva/5) * 5
  tilt <- rtruncnorm(n, a=0, b=100, mean=3.7, sd=1.2) # from https://www.dovepress.com/getfile.php?fileID=76920
  decent <- rtruncnorm(n, a=0, b=Inf, mean=0.21, sd=0.17) # from https://www.dovepress.com/getfile.php?fileID=76920
  #rv <- sqrt(1 - beta_pre_dcva^2 - beta_tilt^2 - beta_decent^2)
  post_dcva <- rtruncnorm(n,
                          a=20,
                          b=1000,
                          mean = (beta0 + (beta_pre_dcva*pre_dcva) + (beta_tilt*tilt) + (beta_decent*decent)),
                          sd=sigma)
  post_dcva <- round(post_dcva/5) * 5
  #post_dcva <- beta0 + (beta_pre_dcva*pre_dcva) + (beta_tilt*tilt) + (beta_decent*decent) + rnorm(1, 0, sigma)
   model <- lm(post_dcva ~ pre_dcva + tilt + decent)
   pvs <- list()
   pvs$tilt <- coef(summary(model))['tilt', 'Pr(>|t|)']
   pvs$decent <- coef(summary(model))['decent', 'Pr(>|t|)']
#   df <- cbind(pre_dcva, tilt, decent, post_dcva)
   return(pvs)
}

fx2 <- function(n, beta0, beta_pre_dcva, beta2, xmean, xsd, xmax, sigma) {
  pre_dcva <- rtruncnorm(n, a=20, b=1000, mean=140, sd=100)
  pre_dcva <- round(pre_dcva/5) * 5
  x <- rtruncnorm(n, a=0, b=xmax, mean=xmean, sd=xsd) 
  #rv <- sqrt(1 - beta_pre_dcva^2 - beta_tilt^2 - beta_decent^2)
  post_dcva <- rtruncnorm(n,
                          a=20,
                          b=1000,
                          mean = (beta0 + (beta_pre_dcva*pre_dcva) + (beta2*x)),
                          sd=sigma)
  post_dcva <- round(post_dcva/5) * 5
  #post_dcva <- beta0 + (beta_pre_dcva*pre_dcva) + (beta_tilt*tilt) + (beta_decent*decent) + rnorm(1, 0, sigma)
  model <- lm(post_dcva ~ pre_dcva + x)
  coef(summary(model))['x', 'Pr(>|t|)']
}

out_tilt_alone <- replicate(1000, fx2(n = 200,
                                beta0 = -75,
                                beta_pre_dcva = .5,
                                beta2 = 5,
                                xmean = 3.7,
                                xsd = 1.2,
                                xmax = 100,
                                sigma = 10))
mean(out_tilt_alone < 0.05)

out_decent_alone <- replicate(10000, fx2(n = 200,
                                      beta0 = -75,
                                      beta_pre_dcva = .5,
                                      beta2 = 40,
                                      xmean = .21,
                                      xsd = .17,
                                      xmax = Inf,
                                      sigma = 10))
mean(out_decent_alone < 0.05)

df <- as.data.frame(fx(n = 200,
   beta0 = -75,
   beta_pre_dcva = .3,
   beta_tilt = 6,
   beta_decent = 41,
   sigma = 10))
plot(df$pre_dcva, df$post_dcva)

out_tilt <- replicate(10000, fx(n = 200,
                          beta0 = -75,
                          beta_pre_dcva = .5,
                          beta_tilt = 5,
                          beta_decent = 40,
                          sigma = 15)[1])
out_decent <- replicate(10000, fx(n = 200,
                               beta0 = -75,
                               beta_pre_dcva = .5,
                               beta_tilt = 5,
                               beta_decent = 40,
                               sigma = 15)[2])

mean(out_tilt < 0.05)
mean(out_decent < 0.05)

rep.ss.tilt <- function(n.iter, tilt.range) { 
  out_tilt <- list()
  for (i in 1:length(tilt.range)) {
    out <- replicate(n.iter, fx(n = 200,
                                       beta0 = -100,
                                       beta_pre_dcva = .5,
                                       beta_tilt = tilt.range[i],
                                       beta_decent = 40,
                                       sigma = 1.5)[1])  
    out_tilt[i] <- mean(out < 0.05)
  }
}

check <- rep.ss.tilt(n.iter=100, tilt.range=6:7)

alcon.sample.sizes <- tribble(
  ~var, ~n, ~b0, ~b_pre, ~b_tilt, ~b_dec, ~power
 #----#---#----#-------#--------#-------#-------#
 "tilt", 200, -100, .5, 6, 40, 
 "tilt", 

)
# assumptions...
# pre_dcva has mean = 200, sd = 150
# tilt has mean 3.7, sd = 1.2 based on prior literature
# decentration has mean 0.21 mm, sd = 0.17 mm based on prior literature
# most patients undergoing procedure have significant improvement in dcva pre- to post
# greater pre-dcva is associated with greater reduction in dcva (improvement in vision)
# higher tilt predicts higher post-dcva (worse vision impairment)
# higher decentration predicts higher post-dcva (worse vision impairment)
  x2 <- rtruncnorm(n, a=20, b=1000, mean=200, sd=150)
  x2 <- round(x2/5) * 5
  df <- cbind(x, x2) |> as.data.frame()
  cor(df)
  h <- ggplot(df) + 
    geom_histogram(mapping = aes(x), alpha = 0.5, fill = "blue") + 
    geom_histogram(mapping = aes(x2), alpha = 0.5, fill = "red")
  return(h)
}


fx(200)

## See also: 
##   https://github.com/krisanathema/Tutorials/blob/master/Cumulative%20Link%20Mixed-effects%20Models_R/Tutorial_CLMM_script.Rmd
##   https://user2021.r-project.org/participation/technical_notes/t186/technote/
##   


# library(rms)
# 
# tmpfun <- function(n, beta0, beta1, beta2) {
#   x <- runif(n, 0, 10)
#   eta1 <- beta0 + beta1*x
#   eta2 <- eta1 + beta2
#   p1 <- exp(eta1)/(1+exp(eta1))
#   p2 <- exp(eta2)/(1+exp(eta2))
#   tmp <- runif(n)
#   y <- (tmp < p1) + (tmp < p2)
#   fit <- lrm(y~x)
#   fit$stats[5]
# }
# 
# out <- replicate(1000, tmpfun(100, -1/2, 1/4, 1/4))
# mean( out < 0.05 )

library(rms)
library(sn)

tmpfun1 <- function(n, beta0, beta1, beta2, beta3, prx1, prx2) {
  x1 <- rbinom(n, 1, prx1)              # binomial 0, 1
  x2 <- rbinom(n, 1, prx2)              # binomial 0, 1
  eta1 <- beta0 + beta1*x1 + beta2*x2   # first-stage equation
  eta2 <- eta1 + beta3                  # second-stage equation
  p1 <- exp(eta1)/(1+exp(eta1))
  p2 <- exp(eta2)/(1+exp(eta2))
  tmp <- runif(n)
  y <- (tmp < p1) + (tmp < p2)
  fit <- lrm(y ~ x1 + x2)
  fit$stats[5]
}




out <- replicate(10000, tmpfun1(n = 200, 
                              beta0 = log(0.25), 
                              beta1 = log(2.5), 
                              beta2 = log(2.5), 
                              beta3 = 1/2,
                              prx1 = 0.1,
                              prx2 = 0.08))
mean( out < 0.05 )


# params <- cp2dp(c(0.05, 0.06, 0.8), "SN")
# sims <- rsn(1000, dp = params)
# decentration_sim <- round(sims, digits = 2)
# hist(decentration_sim[decentration_sims >= 0])

tmpfun2 <- function(n, beta0, beta1, beta2) {
  x1 <- round(rsn(n, dp = cp2dp(c(0.05, 0.06, 0.8), "SN")), digits = 2)
  eta1 <- beta0 + beta1*x1 
  eta2 <- eta1 + beta2
  p1 <- exp(eta1)/(1+exp(eta1))
  p2 <- exp(eta2)/(1+exp(eta2))
  tmp <- runif(n)
  y <- (tmp < p1) + (tmp < p2)
  fit <- lrm(y ~ x1)
  fit$stats[5]
}

out <- replicate(10000, tmpfun2(n = 200, 
                                 beta0 = -1.5, 
                                 beta1 = log(2), 
                                 beta2 = log(2), 
                                 #beta3 = 1/2,
                                 prx = 0.2
                                 ))
mean( out < 0.05 )

library(tidyverse)
library(simstudy)

# Baseline probabilities
# o	20/20 or greater (no visual impairment):  0
# o	20/30 to 20/60 (mild visual impairment):  0.02
# o	20/70 to 20/160 (moderate visual impairment):  0.1
# o	20/200 to 20/400 (severe visual impairment): 0.25
# o	20/500 to 20/1,000 (profound visual impairment): 0.35
# o	Less than 20/1,000 (near-total visual impairment): 0.25
# o	No light perception (total visual impairment): 0.03

baseprobs <- c(0, 0.02, .1, .25, .35, .25, .03)
fu_probs <- c(0.5, 0.3, 0.1, 0.05, 0.03, 0.02, 0)

set.seed(130)
defA <- defData(varname = "BL_UCDVA", formula = "1;7", dist = "uniformInt")
#defA <- defData(defA, varname = "z", formula = "-.7*BL_UCDVA", dist = "nonrandom")
dT_1_cat <- genData(200, defA)
dX_BL <- genOrdCat(dT_1_cat, baseprobs = baseprobs, catVar = "r")
dX_FU <- genOrdCat(dT_1_cat, baseprobs = fu_probs, catVar = "r2")

dX <- bind_cols(select(dX_BL, id, r), select(dX_FU, id, r2)) %>% select(-id...3) %>% rename(id = id...1)


# check
dX %>% group_by(r) %>% summarize(count = n_distinct(id))






library(rms)

tmpfun <- function(n, beta0, beta1, beta2, beta3, beta4, beta5, beta6) {
  x <- runif(n, 0, 10)
  eta1 <- beta0 + beta1*x
  eta2 <- eta1 + beta2
  p1 <- exp(eta1)/(1+exp(eta1))
  p2 <- exp(eta2)/(1+exp(eta2))
  tmp <- runif(n)
  y <- (tmp < p1) + (tmp < p2)
  fit <- lrm(y~x)
  fit$stats[5]
}

out <- replicate(1000, tmpfun(100, -1/2, 1/4, 1/4))
mean( out < 0.05 )